package net.maui.morselab.decoder

import net.maui.morselab.generator.MorseSoundGenerator
import net.maui.morselab.utils.AudioUtils
import org.junit.Assert
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.min

class MorseDecoderTest {

    // --- Test Configuration ---
    private val sampleRate = 16000
    private val blockSize = 512
    private val targetFreq = 700.0
    private val wpm = 20 // Words per minute
    private val farnsworthWpm = 20 // Using same WPM for standard spacing

    private lateinit var decoder: MorseDecoder

    private val morseSoundGenerator = MorseSoundGenerator()
    private var decodedString = ""

    @Before
    fun setup() {
        // Reset the decoded string before each test
        decodedString = ""

        // Initialize the MorseDecoder to listen for the decoded text
        decoder = MorseDecoder(
            onDecoded = { decoded ->
                // The decoder might call this multiple times for "S" and "O"
                // Append the result to capture the full word.
                decodedString += decoded.trim()
            },
            targetFreq = targetFreq,
            sampleRate = sampleRate,
            blockSize = blockSize
        )
    }

    @Test
    fun `decoder correctly decodes SOS from audio generated by MorseSoundGenerator`() {
        // 1. Generate the 16-bit PCM audio as a ByteArray
        val audioByteArray = morseSoundGenerator.generate(
            text = "SOS ", // Add trailing space for word gap
            wpm = wpm,
            farnsworthWpm = farnsworthWpm,
            frequency = targetFreq.toInt(),
            sampleRate = sampleRate
        )

        // 2. Convert ByteArray to FloatArray and feed to the decoder
        val audioFloatArray = AudioUtils.bytesToFloat(byteArray = audioByteArray)
        feedDataToDecoder(decoder, audioFloatArray)

        // 3. Assert the final decoded string is correct
        assertEquals("SOS", decodedString)
    }

    @Test
    fun `decoder correctly decodes HI SOS from wav file`() {
        // 1. Load the WAV file from test resources as a ByteArray
        val audioByteArray = WavReader.readAudioData("hi-sos.wav")
        Assert.assertNotNull("Failed to read hi-sos.wav file from resources.", audioByteArray)

        // 2. Convert the 16-bit PCM ByteArray to a normalized FloatArray
        val audioFloatArray = AudioUtils.bytesToFloat(audioByteArray!!)

        decoder.reset()

        // 3. Feed the audio data into the decoder in chunks
        feedDataToDecoder(decoder, audioFloatArray)

        // 4. Assert the final decoded string is correct
        assertEquals("HI SOS", decodedString)
    }

    @Test
    fun `decoder correctly decodes HI from audio generated by MorseSoundGenerator`() {
        // 1. Generate the 16-bit PCM audio as a ByteArray
        val audioByteArray = morseSoundGenerator.generate(
            text = "HI ", // Add trailing space for word gap
            wpm = wpm,
            farnsworthWpm = farnsworthWpm,
            frequency = targetFreq.toInt(),
            sampleRate = sampleRate
        )

        // 2. Convert ByteArray to FloatArray and feed to the decoder
        val audioFloatArray = AudioUtils.bytesToFloat(audioByteArray)
        feedDataToDecoder(decoder, audioFloatArray)

        // 3. Assert the result
        assertEquals("HI", decodedString)
    }

    /**
     * Helper function to chunk a larger audio array into blocks and pass them to the decoder.
     */
    private fun feedDataToDecoder(decoder: MorseDecoder, audioData: FloatArray) {
        var offset = 0
        while (offset < audioData.size) {
            val remaining = audioData.size - offset
            val currentBlockSize = min(blockSize, remaining)
            val block = audioData.copyOfRange(offset, offset + currentBlockSize)

            // The decoder expects a full block, so pad with silence if necessary
            val finalBlock = if (block.size < blockSize) {
                block.copyOf(blockSize) // Pads with 0f by default
            } else {
                block
            }

            decoder.processBuffer(finalBlock, 0)
            offset += currentBlockSize
        }
    }
}
